<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebRTC Test</title>
    <style>
        body { font-family: sans-serif; background-color: #2c2c2c; color: white; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        .videos { display: flex; gap: 20px; margin-bottom: 20px; }
        video { width: 48%; border: 2px solid #555; background: #000; }
        .controls, .info { background: #3a3a3a; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        input, button { padding: 10px; border-radius: 5px; border: none; font-size: 16px; }
        button { background-color: #007bff; color: white; cursor: pointer; }
        button:disabled { background-color: #555; cursor: not-allowed; }
    </style>
</head>
<body>

<div class="container">
    <h1>Simple WebRTC Call Test</h1>
    
    <div class="info">
        <p>Your Session ID: <b id="my-sid">Connecting...</b></p>
        <p>Status: <span id="status">Idle</span></p>
    </div>

    <div class="controls">
        <input type="text" id="peer-sid-input" placeholder="Enter Peer's Session ID here">
        <button id="start-btn">Start Camera</button>
        <button id="call-btn" disabled>Call</button>
        <button id="hangup-btn" disabled>Hang Up</button>
    </div>
    
    <div class="videos">
        <video id="localVideo" autoplay muted playsinline></video>
        <video id="remoteVideo" autoplay playsinline></video>
    </div>
</div>

<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const socket = io();

    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const mySidElem = document.getElementById('my-sid');
    const statusElem = document.getElementById('status');
    const peerSidInput = document.getElementById('peer-sid-input');
    
    const startBtn = document.getElementById('start-btn');
    const callBtn = document.getElementById('call-btn');
    const hangupBtn = document.getElementById('hangup-btn');

    let localStream;
    let peerConnection;
    let mySid;

    const configuration = { iceServers: [] }; // No STUN/TURN needed for local network

    // --- 1. Connection and Setup ---

    socket.on('connect', () => {
        statusElem.textContent = 'Connected to server.';
    });

    socket.on('your_session_id', (data) => {
        mySid = data.sid;
        mySidElem.textContent = mySid;
    });

    startBtn.addEventListener('click', async () => {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            localVideo.srcObject = localStream;
            startBtn.disabled = true;
            callBtn.disabled = false;
            statusElem.textContent = "Camera started. Ready to call.";
        } catch (error) {
            console.error("Error accessing media devices:", error);
            statusElem.textContent = "Error: Could not access camera/mic.";
        }
    });

    // --- 2. Signaling and Call Logic ---

    socket.on('signal', async ({ from_sid, payload }) => {
        if (payload.sdp) { // This is an offer or an answer
            if (!peerConnection) {
                // This happens when receiving an offer
                createPeerConnection(from_sid);
            }
            await peerConnection.setRemoteDescription(new RTCSessionDescription(payload.sdp));

            if (payload.sdp.type === 'offer') {
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                socket.emit('signal', { to_sid: from_sid, payload: { sdp: peerConnection.localDescription } });
                statusElem.textContent = `Incoming call from ${from_sid}. Answered.`;
                hangupBtn.disabled = false;
            }
        } else if (payload.candidate) { // This is an ICE candidate
            if (peerConnection) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(payload.candidate));
            }
        } else if (payload.type === 'hangup') {
            closeCall();
            statusElem.textContent = `Call ended by peer.`;
        }
    });

    function createPeerConnection(peerSid) {
        peerConnection = new RTCPeerConnection(configuration);

        localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
        });

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('signal', { to_sid: peerSid, payload: { candidate: event.candidate } });
            }
        };

        peerConnection.ontrack = (event) => {
            remoteVideo.srcObject = event.streams[0];
        };
    }

    callBtn.addEventListener('click', async () => {
        const peerSid = peerSidInput.value.trim();
        if (!peerSid) {
            alert('Please enter the Peer SID to call.');
            return;
        }

        createPeerConnection(peerSid);
        
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        socket.emit('signal', { to_sid: peerSid, payload: { sdp: peerConnection.localDescription } });
        statusElem.textContent = `Calling ${peerSid}...`;
        callBtn.disabled = true;
        hangupBtn.disabled = false;
    });

    // --- 3. Hang Up Logic ---

    function closeCall() {
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }
        remoteVideo.srcObject = null;
        startBtn.disabled = false;
        callBtn.disabled = false;
        hangupBtn.disabled = true;
        statusElem.textContent = 'Idle';
    }

    hangupBtn.addEventListener('click', () => {
        const peerSid = peerSidInput.value.trim();
        if (peerSid) {
             socket.emit('signal', { to_sid: peerSid, payload: { type: 'hangup' } });
        }
        closeCall();
        statusElem.textContent = 'Call ended.';
    });
});
</script>
</body>
</html>
